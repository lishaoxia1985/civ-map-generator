use rand::Rng;

use crate::{
    component::map_component::{base_terrain::BaseTerrain, terrain_type::TerrainType},
    tile::Tile,
    tile_map::{MapParameters, TileMap},
};

use super::generate_area_ids::LandmassType;

impl TileMap {
    /// Generate [`BaseTerrain::Lake`] on the map.
    ///
    /// This function is used because when we create the map by [`TileMap::generate_terrain_types`], some water areas will be created surrounded by land.
    /// If these water areas are small enough, they will be considered as lakes and will be replaced by [`BaseTerrain::Lake`].
    pub fn generate_lakes(&mut self, map_parameters: &MapParameters) {
        let candidate_lake_area_ids: Vec<_> = self
            .landmass_list
            .iter()
            .filter(|landmass| {
                landmass.landmass_type == LandmassType::Water
                    && landmass.size <= map_parameters.lake_max_area_size
            })
            .map(|landmass| landmass.id)
            .collect();

        self.all_tiles().for_each(|tile| {
            if candidate_lake_area_ids.contains(&tile.landmass_id(self)) {
                self.base_terrain_query[tile.index()] = BaseTerrain::Lake;
            }
        });
    }

    /// Add lakes to the map.
    ///
    /// Besides the lakes generated by [`TileMap::generate_lakes`], this function will add more lakes to the map.
    pub fn add_lakes(&mut self, map_parameters: &MapParameters) {
        let large_lake_num = map_parameters.large_lake_num;
        // TODO: `lake_plot_rand` should be configurable by the user in the future.
        let lake_plot_rand = 25;

        let mut num_large_lakes_added = 0;

        self.all_tiles().for_each(|tile| {
            if self.can_add_lake(tile)
                && self.random_number_generator.gen_range(0..lake_plot_rand) == 0
            {
                if num_large_lakes_added < large_lake_num {
                    let add_more_lakes = self.add_more_lake(tile);

                    if add_more_lakes {
                        num_large_lakes_added += 1;
                    }
                }
                self.terrain_type_query[tile.index()] = TerrainType::Water;
                self.base_terrain_query[tile.index()] = BaseTerrain::Lake;
                self.feature_query[tile.index()] = None;
            }
        });
    }

    /// Transform the neighboring tiles of the given tile into lakes if possible.
    /// # Notice
    /// This function is only used in CIV6.
    fn add_more_lake(&mut self, tile: Tile) -> bool {
        let grid = self.world_grid.grid;

        let mut large_lake = 0;

        let mut lake_tiles = Vec::new();

        // Get the candidate tiles for the lake.
        // Notice: Don't transform the candidate tiles into lakes in this loop,
        // because if we do so, the result will not be as expected.
        tile.neighbor_tiles(grid).for_each(|neighbor_tile| {
            // 1. Check if the tile can have a lake.
            // 2. Randomly decide whether to add a lake to the tile. Larger `large_lake`, less likely to add a lake.
            if self.can_add_lake(neighbor_tile)
                && self.random_number_generator.gen_range(0..(large_lake + 4)) < 3
            {
                lake_tiles.push(neighbor_tile);
                large_lake += 1;
            }
        });

        lake_tiles.into_iter().for_each(|tile| {
            self.terrain_type_query[tile.index()] = TerrainType::Water;
            self.base_terrain_query[tile.index()] = BaseTerrain::Lake;
            self.feature_query[tile.index()] = None;
        });

        large_lake > 2
    }

    /// Checks if a tile can have a lake.
    ///
    /// A tile can have a lake if it meets all of the following conditions:
    /// 1. It is not water.
    /// 2. It is not a natural wonder.
    /// 3. It is not adjacent to a river.
    /// 4. It is not adjacent to water.
    /// 5. It is not adjacent to a natural wonder.
    ///
    /// # Arguments
    ///
    /// - `tile`: The tile being checked.
    ///
    /// # Returns
    ///
    /// Returns `true` if the tile can have a lake, otherwise `false`.
    fn can_add_lake(&self, tile: Tile) -> bool {
        let grid = self.world_grid.grid;
        // Check if the current tile is suitable for a lake
        if tile.terrain_type(self) == TerrainType::Water
            || tile.natural_wonder(self).is_some()
            || tile.has_river(self)
        {
            return false;
        }

        // Check if all neighbor tiles are also suitable
        tile.neighbor_tiles(grid).all(|neighbor_tile| {
            neighbor_tile.terrain_type(self) != TerrainType::Water
                && neighbor_tile.natural_wonder(self).is_none()
        })
    }
}
